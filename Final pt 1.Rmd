---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Cmd+Shift+Enter*. 

```{r}
#Load Data
library(readr)
loans50k <- read_csv("loans50k.csv")
```
```{r}
library(tidyr)
library(dplyr)
#Make new variable: Set "Good" and "Bad" Loans, all else "blank" to be removed later
df <-
  loans50k %>%
  mutate(payment_status = case_when(
    status == "Fully Paid" ~ "Good", 
    status == "Charged Off" ~ "Bad",
    TRUE ~ ""
  ))

#check total

#change the empty string cells to NAs
df[df==""]<-NA

#Test where all NAs are to 
which(is.na(df), arr.ind=TRUE)
#Found a bunch in "employment". Going to eliminate on account of too many levels/NA values.  
df$employment<- NULL

```

```{r}
#Probably best to get rid of the null values we aren't interested in payment_status:
df<-df %>% drop_na(payment_status)

#Test where the NAs are again:
which(is.na(df), arr.ind=TRUE)

#Row 34806 is missing all values, eliminate and test again:
df <- df[-c(34806),] 
which(is.na(df), arr.ind=TRUE)
#last NA values are in bcOpen and bcRatio, of which there are roughtly 400 incomplete entries, 
#or roughly 1% of the dataset. Eliminating these wont be a huge issue. 

#Finally omit all the rows containing NA values. (This will not eliminate the NA values in "length" as they are strings)
df1<-na.omit(df)


#consolidate "verified" variable into two levels instead of three
library(plyr)
df1$verified<-revalue(df1$verified, c("Source Verified"="Verified"))
unique(df1$verified)

```

```{r}
#make subset of numerical data check covariance matrix on numeric factors. 
dfNum<-select_if(df1, is.numeric)
m<-cor(dfNum)
#easy way to find strong correlations; arbitrary value set at .8
strongCorrelations = m > .8
dfNum$totalIlLim


#Found few redundant variables...will eliminate: 

#Final check for number of levels in each categorical variable
dfChar<-select_if(df1,is.character) 
sapply((sapply(dfChar,unique)),length)

cor(df$avgBal,df$totalLim)
#Eliminating: totalPaid, employment (already done), payment,revolRatio, avgBal, totalLim,state,status,loanID
df_New = as.data.frame(subset(df1, select = -c(totalPaid, payment,revolRatio, avgBal, totalLim,state,status,loanID,totalIlLim,totalBcLim)))

#Test for instances of each level
x=sapply(dfCont,count)

#going to combine a few levels in "reason" due to the lack of instances
df_New$reason<-revalue(df_New$reason,c("wedding"="other","renewable_energy"="other","house"="major_purchase"))
#Test for instances of each level again
x=sapply(df_New,count)

#lowest #of instances is now above 200
```


```{r}
#make new df of only numeric variables.
dfNum<-select_if(df_New, is.numeric)
dfCont<-select_if(df_New, is.character)
library("moments")
library("ggplot2")
#check out skewness of all numeric variables
sapply(dfNum, hist)
sapply(dfNum,skewness)
#Distributions that have a skewness greater than 1 are generally considered "highly skewed"
#will transform: income, delinq2yr,inq6mth,openAcc,pubRec,totalBal,totalRevLim,accOpen24,bcOpen,totalRevBal

```

```{r}
#function to success of various transformations
tansformAndGetSkew<-function(dist1){
  log=skew(log(dist1))
  lognat=skew(log(dist1,base=exp(1)))
  sqrt=skew(sqrt(dist1))
  curt=skew(sign(dist1) * abs(dist1)^(1/3) )
  fthrt=skew(sign(dist1)^(1/4))
  reciprical=skew(1/dist1)
  
  list1<- c(log,lognat,sqrt,curt,fthrt,reciprical)
  
  return(list1)
}
#apply function to all numerical variables
sapply(dfNum, tansformAndGetSkew)

#Use results to infer which might be the best type of transformation
#Changing pubRec & delinqyr to categorical variables due to too many instances of '0' in both. 
boxplot(df_New$pubRec)
#use unique() to determine breaks
unique(df_New$pubRec)

#Make three levels, one containing zero, 1-3, and more than 3
cutPubRec<-cut(df_New$pubRec,breaks=c(-.10,.1,3,14))
levels(cutPubRec)

#DO THIS AGAIN But with delinqyr
cutPubRec<-cut(df_New$pubRec,breaks=c(-.10,.1,3,14))
levels(cutPubRec)


```

```{r}


#begin transformations
df_New$income<-log(df_New$income)

z=sign(df_New$delinq2yr) * abs(df_New$delinq2yr)^(1/80) 
hist(z)
hist(df_New$delinq2yr)
Income_sqrt = sqrt(df_New$income)
skew(Income_sqrt)

```




```
```{r}
#Eventually...
mylogit <- glm(as.factor(payment_status) ~ ., data = df_New, family = "binomial")


```

```{r}

```


